<!-- anchor: blueprint-header -->
# System Architecture Blueprint: Flow Agent Reasoning Control
**Version:** 1.0  
**Date:** November 8, 2025  
**Generated By:** Codex (GPT-5)

<!-- anchor: introduction-goals -->
## 1. Introduction & Goals

<!-- anchor: project-vision -->
### 1.1. Project Vision
Flow Agent Reasoning Control extends `codex-flow` so workflow authors can declaratively set reasoning depth and summary verbosity per agent and per step, with those settings validated, propagated to `codex exec`, and reflected in templates, logs, and documentation for predictable automation outcomes.

<!-- anchor: key-objectives -->
### 1.2. Key Objectives
- Deliver schema and serde support for `reasoning_effort` (`minimal|low|medium|high`) and `reasoning_summary` (`auto|concise|detailed|none`) at both agent and step layers.
- Ensure the runner resolves overrides (defaults → agent → step) and passes the final reasoning parameters to `codex exec` in both real and mock modes.
- Provide guardrails: fast config validation, descriptive errors, and compatibility fallbacks for engines that cannot honor reasoning flags.
- Surface observability signals (verbose logs, mock artifacts, telemetry) that reveal which reasoning mode executed each step.
- Update `flow init` scaffolds, docs, and examples so new workflows showcase reasoning options without breaking legacy configs.

<!-- anchor: scope -->
### 1.3. Scope
**In scope:** TOML schema evolution, serde models, validation logic, CLI flag plumbing, mock/real execution annotations, documentation + template updates, and targeted regression tests.  
**Out of scope:** Changes to Codex backend reasoning algorithms, UI builders for editing configs, scheduler-level orchestration changes, or non-Codex engine feature work beyond graceful degradation.

<!-- anchor: key-assumptions -->
### 1.4. Key Assumptions
- `codex exec` already exposes compatible reasoning flags and summary toggles.
- Workflow authors are comfortable editing TOML files directly and running CLI commands.
- Flow runners (local and CI) share the same Codex binaries and authentication context.
- Documentation publishing (`codex-rs/docs`) can be updated in lockstep with code changes.

<!-- anchor: architectural-drivers -->
## 2. Architectural Drivers

<!-- anchor: functional-requirements-summary -->
### 2.1. Functional Requirements Summary
- FR-001: Agent schema must accept reasoning fields and expose them throughout the runner lifecycle.
- FR-002: Steps override agent-level reasoning without mutating shared definitions, enabling fine-grained control.
- FR-003: CLI invocations to `codex exec` must include the resolved reasoning flags/JSON payloads in both real and mock modes.
- FR-004: Validation and telemetry should reject invalid values early while logging active reasoning per step for auditability.
- FR-005: Templates, docs, and `flow init` must demonstrate how to set and verify reasoning behavior.

<!-- anchor: non-functional-requirements -->
### 2.2. Non-Functional Requirements (NFRs)
- **Compatibility (NFR-COMP-001):** Legacy configs without reasoning fields must deserialize unchanged; regression tests should confirm zero breaking changes.
- **Observability (NFR-UX-001):** Verbose CLI output needs to show `reasoning=<level>` for each executed step, including mock mode.
- **Validation Performance (NFR-CONF-001):** Detect invalid reasoning values in under 100 ms per file to keep `flow run` responsive.
- **Documentation Freshness (NFR-DOC-001):** Docs and templates update alongside code, ensuring discoverability of the new fields.
- **Cost & Latency Guardrails:** Defaults prevent unnecessary high-effort reasoning and error messages explain trade-offs when users override.

<!-- anchor: constraints-preferences -->
### 2.3. Constraints & Preferences
- Implementation remains within the existing Rust `codex-flow` crate using Serde for config parsing and the established defaults → agent → step precedence model.
- No new persistent services; workflows, templates, and mock transcripts stay on the local filesystem within `.codex-flow`.
- Execution continues to rely on the external `codex exec` binary via CLI/JSON streams; network dependencies are unchanged.
- Release and deployment processes stay the same (pre-built binaries, homebrew, etc.), so features must remain opt-in through config only.
- Architecture must remain engine-agnostic so future non-Codex engines can ignore unsupported reasoning flags gracefully.
